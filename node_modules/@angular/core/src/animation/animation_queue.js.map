{"version":3,"sources":["../../../../../modules/@angular/core/src/animation/animation_queue.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AACH,OAAO,EAAA,UAAE,EAAU,MAAA,gBAAA,CAAA;AACnB,OAAO,EAAA,MAAE,EAAM,MAAA,iBAAA,CAAA;AAEf;IAEA;;OAEG;IACH,wBAAsB,KAAO;QAAP,UAAA,GAAA,KAAA,CAAO;QAFpB,YAAA,GAA6B,EAAA,CAAG;IAEL,CAAA;IACpC;;;OAGG;IACH,gCAHG,GAGH,UAHG,MAAA,IAAkC,IAAA,CAAK,OAAC,CAAO,IAAC,CAAI,MAAC,CAAM,CAAC,CAAC,CAAA;IAIhE;;OAEG;IACH,8BALG,GAKH;QAAA,iBAgBG;QAfC,iDAAiD;QACjD,gDAAgD;QAChD,mDAAmD;QACnD,oDAAoD;QACpD,4DAA4D;QAC5D,uDAAuD;QACvD,oDAAoD;QACpD,EAAE,CAAC,CAAC,IALC,CAAI,OAAC,CAAO,MAAC,CAAM,CAAC,CAAA;YAMvB,IAAI,CALC,KAAC,CAAK,iBAAC,CAAiB;gBAM3B,2DAA2D;gBAC3D,4DAA4D;gBAC5D,oCAAoC;gBACpC,OAAO,CALC,OAAC,CAAO,IAAC,CAAI,CAAC,IAAC,CAAI,cAAM,OAAA,KAAA,CAAK,kBAAC,EAAkB,EAAxB,CAAwB,CAAE,CAAC;YAM9D,CAAC,CALC,CAAC;QAML,CAAC;IACH,CAAC;IACH;;OAEG;IANA,2CAAA,GAOH;QACI,MAAM,CAPC,sBAAC,EAAsB,CAAE;QAShC,OAAO,IAPC,CAAI,OAAC,CAAO,MAAC,EAAO,CAAA;YAQ1B,IAAM,gBAAgB,CAPhB,MAAA,GAAS,IAAA,CAAK,OAAC,CAAO,KAAC,EAAK,CAAE;YAQpC,4DAA4D;YAC5D,2DAA2D;YAC3D,kDAAkD;YAClD,EAAE,CAAC,CAAC,CAPC,MAAC,CAAM,UAAC,EAAU,CAAE,CAAC,CAAA;gBAQxB,MAAM,CAPC,IAAC,EAAI,CAAE;YAQhB,CAAC;QACH,CAAC;IACH,CAAC;IAQH,qBAAC;AAAD,CAtDA,AAsDC;;AAdM,yBAAA,GAAoC;IAQ3C,EAPE,IAAA,EAAM,UAAA,EAAW;CAQlB,CAPC;AAQF,kBAAkB;AANX,6BAAA,GAAiF,cAAM,OAAA;IAQ9F,EAAC,IAPC,EAAK,MAAA,GAAO;CAQb,EAT6F,CAS7F,CAPC;AAUF;IACA,gBAAgB;IAChB,cAAc,CAAC,UAAU,CAAC;IAC1B;;;OAGG;IACH,cAAc,CAAC,cAAc,CAAC;IAC9B,gBAAgB;IAChB,cAAc,CAAC,SAAS,CAAC,OAAO,CAAC;IACjC,gBAAgB;IAChB,cAAc,CAAC,SAAS,CAAC,KAAK,CAAC;AAC/B,CAAC","file":"animation_queue.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injectable} from '../di/metadata';\nimport {NgZone} from '../zone/ng_zone';\nimport {AnimationPlayer} from './animation_player';\nexport class AnimationQueue {\npublic entries: AnimationPlayer[] = [];\n/**\n * @param {?} _zone\n */\nconstructor(private _zone: NgZone) {}\n/**\n * @param {?} player\n * @return {?}\n */\nenqueue(player: AnimationPlayer) { this.entries.push(player); }\n/**\n * @return {?}\n */\nflush() {\n    // given that each animation player may set aside\n    // microtasks and rely on DOM-based events, this\n    // will cause Angular to run change detection after\n    // each request. This sidesteps the issue. If a user\n    // hooks into an animation via (@anim.start) or (@anim.done)\n    // then those methods will automatically trigger change\n    // detection by wrapping themselves inside of a zone\n    if (this.entries.length) {\n      this._zone.runOutsideAngular(() => {\n        // this code is wrapped into a single promise such that the\n        // onStart and onDone player callbacks are triggered outside\n        // of the digest cycle of animations\n        Promise.resolve(null).then(() => this._triggerAnimations());\n      });\n    }\n  }\n/**\n * @return {?}\n */\nprivate _triggerAnimations() {\n    NgZone.assertNotInAngularZone();\n\n    while (this.entries.length) {\n      const /** @type {?} */ player = this.entries.shift();\n      // in the event that an animation throws an error then we do\n      // not want to re-run animations on any previous animations\n      // if they have already been kicked off beforehand\n      if (!player.hasStarted()) {\n        player.play();\n      }\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n];\n}\n\nfunction AnimationQueue_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationQueue.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAnimationQueue.ctorParameters;\n/** @type {?} */\nAnimationQueue.prototype.entries;\n/** @type {?} */\nAnimationQueue.prototype._zone;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}