{"version":3,"sources":["../../../../../modules/@angular/core/src/di/reflective_injector.ts"],"names":[],"mappings":"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","file":"reflective_injector.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst /** @type {?} */ UNDEFINED = new Object();\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n * \n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n * \n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n * \n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n * \n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n * \n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class ReflectiveInjector implements Injector {\n/**\n * Turns an array of provider definitions into an array of resolved providers.\n * \n * A resolution is a process of flattening multiple nested arrays and converting individual\n * providers into an array of {\\@link ResolvedReflectiveProvider}s.\n * \n * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n * \n * expect(providers.length).toEqual(2);\n * \n * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n * expect(providers[0].key.displayName).toBe(\"Car\");\n * expect(providers[0].dependencies.length).toEqual(1);\n * expect(providers[0].factory).toBeDefined();\n * \n * expect(providers[1].key.displayName).toBe(\"Engine\");\n * });\n * ```\n * \n * See {\\@link ReflectiveInjector#fromResolvedProviders} for more info.\n * @param {?} providers\n * @return {?}\n */\nstatic resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n/**\n * Resolves an array of providers and creates an injector from those providers.\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \n * This function is slower than the corresponding `fromResolvedProviders`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#fromResolvedProviders}.\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic resolveAndCreate(providers: Provider[], parent: Injector = null): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n/**\n * Creates an injector from previously resolved providers.\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, Engine]);\n * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \\@experimental\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent: Injector = null):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n/**\n * Parent of this injector.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n * \n * ```typescript\n * var parent = ReflectiveInjector.resolveAndCreate([]);\n * var child = parent.resolveAndCreateChild([]);\n * expect(child.parent).toBe(parent);\n * ```\n * @abstract\n * @return {?}\n */\nparent() {}\n/**\n * Resolves an array of providers and creates a child injector from those providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n * var child = parent.resolveAndCreateChild([ChildProvider]);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * \n * This function is slower than the corresponding `createChildFromResolved`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#createChildFromResolved}.\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]) {}\n/**\n * Creates a child injector from previously resolved providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n * \n * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n * var child = parent.createChildFromResolved(childProviders);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * @abstract\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]) {}\n/**\n * Resolves a provider and instantiates an object in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * \n * var car = injector.resolveAndInstantiate(Car);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider) {}\n/**\n * Instantiates an object using a resolved provider in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * var carProvider = ReflectiveInjector.resolve([Car])[0];\n * var car = injector.instantiateResolved(carProvider);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider) {}\n/**\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  /** @internal */\n  _constructionCounter: number = 0;\npublic _providers: ResolvedReflectiveProvider[];\npublic _parent: Injector;\n\n  keyIds: number[];\n  objs: any[];\n/**\n * Private\n * @param {?} _providers\n * @param {?=} _parent\n */\nconstructor(_providers: ResolvedReflectiveProvider[], _parent: Injector = null) {\n    this._providers = _providers;\n    this._parent = _parent;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n/**\n * @return {?}\n */\nget parent(): Injector { return this._parent; }\n/**\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n/**\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const /** @type {?} */ inj = new ReflectiveInjector_(providers);\n    inj._parent = this;\n    return inj;\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\ngetProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n/**\n * \\@internal\n * @param {?} provider\n * @return {?}\n */\n_new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n/**\n * @return {?}\n */\nprivate _getMaxNumberOfObjects(): number { return this.objs.length; }\n/**\n * @param {?} provider\n * @return {?}\n */\nprivate _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const /** @type {?} */ res = new Array(provider.resolvedFactories.length);\n      for (let /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n/**\n * @param {?} provider\n * @param {?} ResolvedReflectiveFactory\n * @return {?}\n */\nprivate _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const /** @type {?} */ factory = ResolvedReflectiveFactory.factory;\n\n    let /** @type {?} */ deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch ( /** @type {?} */e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let /** @type {?} */ obj: any;\n    try {\n      obj = factory(...deps);\n    } catch ( /** @type {?} */e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n/**\n * @param {?} dep\n * @return {?}\n */\nprivate _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n/**\n * @param {?} key\n * @param {?} visibility\n * @param {?} notFoundValue\n * @return {?}\n */\nprivate _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf, notFoundValue: any): any {\n    if (key === INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n/**\n * @param {?} keyId\n * @return {?}\n */\nprivate _getObjByKeyId(keyId: number): any {\n    for (let /** @type {?} */ i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const /** @type {?} */ obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @param {?} visibility\n * @return {?}\n */\n_getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf): any {\n    let /** @type {?} */ inj: Injector;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this._parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const /** @type {?} */ inj_ = /** @type {?} */(( <ReflectiveInjector_>inj));\n      const /** @type {?} */ obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_._parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n/**\n * @return {?}\n */\nget displayName(): string {\n    const /** @type {?} */ providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n/**\n * @return {?}\n */\ntoString(): string { return this.displayName; }\n}\n\nfunction ReflectiveInjector__tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._constructionCounter;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._providers;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._parent;\n/** @type {?} */\nReflectiveInjector_.prototype.keyIds;\n/** @type {?} */\nReflectiveInjector_.prototype.objs;\n}\n\n\nconst /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);\n/**\n * @param {?} injector\n * @param {?} fn\n * @return {?}\n */\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const /** @type {?} */ res: any[] = new Array(injector._providers.length);\n  for (let /** @type {?} */ i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n"]}