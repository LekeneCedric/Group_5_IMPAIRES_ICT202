{"version":3,"sources":["../../../../../../modules/@angular/core/src/change_detection/differs/iterable_differs.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAA,QAAE,EAAmB,QAAA,EAAS,MAAA,UAAA,CAAA;AACrC,OAAO,EAAA,uBAAE,EAAwB,SAAA,EAAU,MAAA,mBAAA,CAAA;AA0I3C;;;GAGG;AACH;IAKA;;OAEG;IACH,yBAFG,SAA4C;QAAE,IAAA,CAAA,SAAA,GAAA,SAAA,CAAA;IAAA,CAAA;IAGjD;;;;OAIG;IALA,sBAAA,GAMH,UANG,SAAA,EAAA,MAAA;QAOC,EAAE,CAAC,CAAC,SANC,CAAS,MAAC,CAAM,CAAC,CAAC,CAAA;YAOrB,IAAM,gBAAgB,CANhB,MAAA,GAAS,MAAA,CAAO,SAAC,CAAS,KAAC,EAAK,CAAE;YAOxC,SAAS,GANG,SAAA,CAAU,MAAC,CAAM,MAAC,CAAM,CAAC;YAOrC,MAAM,CANC,IAAI,eAAA,CAAgB,SAAC,CAAS,CAAC;QAOxC,CAAC;QANC,IAAA,CAAK,CAAA;YAOL,MAAM,CANC,IAAI,eAAA,CAAgB,SAAC,CAAS,CAAC;QAOxC,CAAC;IACH,CAAC;IACH;;;;;;;;;;;;;;;;;;;;OAoBG;IANA,sBAAA,GAOH,UAPG,SAAA;QAQC,MAAM,CAPC;YAQL,OAAO,EAPE,eAAA;YAQT,UAAU,EAPE,UAAA,MAAS;gBAQnB,EAAE,CAAC,CAAC,CAPC,MAAC,CAAM,CAAC,CAAA;oBAQX,0FAA0F;oBAC1F,KAAK;oBACL,6EAA6E;oBAC7E,MAPM,IAAI,KAAA,CAAM,yDAAC,CAAyD,CAAC;gBAQ7E,CAAC;gBACD,MAAM,CAPC,eAAA,CAAgB,MAAC,CAAM,SAAC,EAAU,MAAA,CAAO,CAAC;YAQnD,CAAC;YACD,6FAA6F;YAC7F,IAAI,EAPE,CAAA,CAAE,eAAC,EAAgB,IAAI,QAAA,EAAS,EAAG,IAAI,QAAA,EAAS,CAAE,CAAC;SAQ1D,CAPC;IAQJ,CAAC;IACH;;;OAGG;IACH,8BAVG,GAUH,UAVG,QAAA;QAWC,IAAM,gBAAgB,CAVhB,OAAA,GAAU,IAAA,CAAK,SAAC,CAAS,IAAC,CAAI,UAAA,CAAC,IAAI,OAAA,CAAA,CAAE,QAAC,CAAQ,QAAC,CAAQ,EAApB,CAAoB,CAAC,CAAC;QAW/D,EAAE,CAAC,CAAC,SAVC,CAAS,OAAC,CAAO,CAAC,CAAC,CAAA;YAWtB,MAAM,CAVC,OAAA,CAAQ;QAWjB,CAAC;QAVC,IAAA,CAAK,CAAA;YAWL,MAVM,IAAI,KAAA,CAWN,6CAA2C,QAVC,mBAAQ,uBAAc,CAAuB,QAAC,CAAQ,MAAC,CAAG,CAAC;QAW7G,CAAC;IACH,CAAC;IACH,sBAAC;AAAD,CAzEA,AAyEC,IAAA;;AAED;IACA;;;OAGG;IACH,eAAe,CAAC,SAAS,CAAC,SAAS,CAAC;AACpC,CAAC","file":"iterable_differs.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Optional, Provider, SkipSelf} from '../../di';\nimport {getTypeNameForDebugging, isPresent} from '../../facade/lang';\nimport {ChangeDetectorRef} from '../change_detector_ref';\n\n/**\n * A type describing supported interable types.\n *\n * @stable\n */\nexport type NgIterable<T> = Array<T>| Iterable<T>;\n\n/**\n * A strategy for tracking changes over time to an iterable. Used by {@link NgFor} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @stable\n */\nexport interface IterableDiffer<V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: NgIterable<V>): IterableChanges<V>;\n}\n\n/**\n * An object describing the changes in the `Iterable` collection since last time\n * `IterableDiffer#diff()` was invoked.\n *\n * @stable\n */\nexport interface IterableChanges<V> {\n  /**\n   * Iterate over all changes. `IterableChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /**\n   * Iterate over a set of operations which when applied to the original `Iterable` will produce the\n   * new `Iterable`.\n   *\n   * NOTE: These are not necessarily the actual operations which were applied to the original\n   * `Iterable`, rather these are a set of computed operations which may not be the same as the\n   * ones applied.\n   *\n   * @param record A change which needs to be applied\n   * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `previousIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `currentIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   */\n  forEachOperation(\n      fn: (record: IterableChangeRecord<V>, previousIndex: number, currentIndex: number) => void):\n      void;\n\n  /**\n   * Iterate over changes in the order of original `Iterable` showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all added items. */\n  forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all moved items. */\n  forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all removed items. */\n  forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all items which had their identity (as computed by the `trackByFn`) changed. */\n  forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n * @stable\n */\nexport interface IterableChangeRecord<V> {\n  /** Current index of the item in `Iterable` or null if removed. */\n  // TODO(TS2.1): make readonly once we move to TS v2.1\n  /* readonly */ currentIndex: number;\n\n  /** Previous index of the item in `Iterable` or null if added. */\n  // TODO(TS2.1): make readonly once we move to TS v2.1\n  /* readonly */ previousIndex: number;\n\n  /** The item. */\n  // TODO(TS2.1): make readonly once we move to TS v2.1\n  /* readonly */ item: V;\n\n  /** Track by identity as computed by the `trackByFn`. */\n  // TODO(TS2.1): make readonly once we move to TS v2.1\n  /* readonly */ trackById: any;\n}\n\n/**\n * @deprecated v4.0.0 - Use IterableChangeRecord instead.\n */\nexport interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {}\n\n\n/**\n * Nolonger used.\n *\n * @deprecated v4.0.0 - Use TrackByFunction instead\n */\nexport interface TrackByFn { (index: number, item: any): any; }\n\n/**\n * An optional function passed into {@link NgForOf} that defines how to track\n * items in an iterable (e.g. fby index or id)\n *\n * @stable\n */\nexport interface TrackByFunction<T> { (index: number, item: T): any; }\n\n/**\n * Provides a factory for {@link IterableDiffer}.\n *\n * @stable\n */\nexport interface IterableDifferFactory {\n  supports(objects: any): boolean;\n  create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\n\n  /**\n   * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter\n   */\n  create<V>(_cdr?: ChangeDetectorRef|TrackByFunction<V>, trackByFn?: TrackByFunction<V>):\n      IterableDiffer<V>;\n}\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n * \\@stable\n */\nexport class IterableDiffers {\n  /**\n   * @deprecated v4.0.0 - Should be private\n   */\n  factories: IterableDifferFactory[];\n/**\n * @param {?} factories\n */\nconstructor(factories: IterableDifferFactory[]) { this.factories = factories; }\n/**\n * @param {?} factories\n * @param {?=} parent\n * @return {?}\n */\nstatic create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers {\n    if (isPresent(parent)) {\n      const /** @type {?} */ copied = parent.factories.slice();\n      factories = factories.concat(copied);\n      return new IterableDiffers(factories);\n    } else {\n      return new IterableDiffers(factories);\n    }\n  }\n/**\n * Takes an array of {\\@link IterableDifferFactory} and returns a provider used to extend the\n * inherited {\\@link IterableDiffers} instance with the provided factories and return a new\n * {\\@link IterableDiffers} instance.\n * \n * The following example shows how to extend an existing list of factories,\n * which will only be applied to the injector for this component and its children.\n * This step is all that's required to make a new {\\@link IterableDiffer} available.\n * \n * ### Example\n * \n * ```\n * \\@Component({ \n *   viewProviders: [\n *     IterableDiffers.extend([new ImmutableListDiffer()])\n *   ]\n * })\n * ```\n * @param {?} factories\n * @return {?}\n */\nstatic extend(factories: IterableDifferFactory[]): Provider {\n    return {\n      provide: IterableDiffers,\n      useFactory: (parent: IterableDiffers) => {\n        if (!parent) {\n          // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\n          // to\n          // bootstrap(), which would override default pipes instead of extending them.\n          throw new Error('Cannot extend IterableDiffers without a parent injector');\n        }\n        return IterableDiffers.create(factories, parent);\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n/**\n * @param {?} iterable\n * @return {?}\n */\nfind(iterable: any): IterableDifferFactory {\n    const /** @type {?} */ factory = this.factories.find(f => f.supports(iterable));\n    if (isPresent(factory)) {\n      return factory;\n    } else {\n      throw new Error(\n          `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);\n    }\n  }\n}\n\nfunction IterableDiffers_tsickle_Closure_declarations() {\n/**\n * @deprecated v4.0.0 - Should be private\n * @type {?}\n */\nIterableDiffers.prototype.factories;\n}\n\n"]}